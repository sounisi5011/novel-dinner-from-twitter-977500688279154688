-
  /**
   * 文字列の最大長を監視する
   * 最大長を超えた場合、TypeErrorをthrowする。
   * @param {string} varName 対象の変数名を指定する文字列。エラー出力で使用される。
   * @param {string} value 監視対象の文字列。
   *     文字列以外の場合も、自動で文字列に変換される。
   * @param {number} maxLength 対象の文字列の最大長。
   *     文字列がこの長さを超えた場合、TypeErrorをthrowする。
   */
  const assertStringLength = (varName, value, maxLength) => {
    const length = String(value).length;
    if (maxLength < length) {
      throw new TypeError(
        `"#{varName}" property must be maximum ${maxLength} characters.\n` +
        `buy it's #{length} characters.`
      )
    }
  };

  /**
   * 文字列がTwitterのID（@username）の形式か監視する。
   * TwitterのIDではない形式の場合、TypeErrorをthrowする。
   * @param {string} varName 対象の変数名を指定する文字列。エラー出力で使用される。
   * @param {string} value 監視対象の文字列。
   *     文字列以外の場合も、自動で文字列に変換される。
   */
  const assertTwitterId = (varName, value) => {
    /*
     * 値を文字列へと変換
     */
    const valueStr = String(value);

    /*
     * 文字列がTwitterのIDの形式ではないかを判定する
     */
    if (!/^@[a-zA-Z0-9_]{1,15}$/.test(valueStr)) {
      const jsonValue = JSON.stringify(valueStr);
      const showValue = (
        60 < jsonValue.length ?
        jsonValue.substr(0, 60) + '..' :
        jsonValue
      );
      throw new TypeError(
        `"#{varName}" property is invalid format. ` +
        'It must be Twitter id format string (ex. "@username").\n' +
        `buy it's value: #{showValue}.`
      )
    }
  };

  /**
   * Dateオブジェクトを見やすい表示に変換する
   * @param {!Date} date 変換元のDateオブジェクト
   * @param {string} format 変換形式を指定する文字列。UNIXのdateコマンド互換
   * @param {number} timezoneSec タイムゾーンの秒数。
   *     例えば、+09:00のタイムゾーンを指定したい場合は、
   *     32400（`9 * 60 * 60`の計算結果）を指定する
   */
  const formatDate = (date, format='%Y-%m-%dT%H:%M:%S%:z', timezoneSec=NaN) => {
    /*
     * 引数の型チェックを行う
     */
    if (!(date && date instanceof Date)) {
      throw new TypeError(
        'formatDate(date, format, timezoneSec):\n' +
        `  date parameter must be Date object.\n` +
        `  buy it's value: ${JSON.stringify(date)}.`
      );
    }
    if (typeof format !== 'string') {
      throw new TypeError(
        'formatDate(date, format, timezoneSec):\n' +
        `  format parameter must be string.\n` +
        `  buy it's value: ${JSON.stringify(format)}.`
      );
    }

    /*
     * timezoneSecパラメータの値を数値へ型変換する。
     * 同時に、小数部を切り捨てる。
     */
    timezoneSec = Math.trunc(timezoneSec);

    /*
     * Dateオブジェクトから、タイムゾーンの秒数を取得する
     */
    const systemTimezoneSec = date.getTimezoneOffset() * -1 * 60;

    if (isFinite(timezoneSec)) {
      /*
       * timezoneSecの値が範囲内かを判定
       */
      if (!(-(24 * 3600) < timezoneSec)) {
        throw new TypeError(
          'formatDate(date, format, timezoneSec):\n' +
          `  timezoneSec parameter must be greater than ${-(24 * 3600)} ` +
          `( ${-(24 * 3600)} < timezoneSec ).\n` +
          `  buy it's value: ${timezoneSec}.`
        );
      } else if (!(timezoneSec < (24 * 3600))) {
        throw new TypeError(
          'formatDate(date, format, timezoneSec):\n' +
          `  timezoneSec parameter must be less than ${24 * 3600} ` +
          `( timezoneSec < ${24 * 3600} ).\n` +
          `  buy it's value: ${timezoneSec}.`
        );
      }

      /*
       * タイムゾーンに合わせて、Dateオブジェクトの時間をずらす
       */
      const unixtime = date.getTime();
      date = new Date(unixtime - (systemTimezoneSec - timezoneSec) * 1000);
    } else {
      /*
       * タイムゾーンの指定が無い場合、Dateオブジェクトのタイムゾーンから求める
       */
      timezoneSec = systemTimezoneSec;
    }

    /*
     * タイムゾーンの文字列に使用する値を求める
     */
    const timezoneSign = timezoneSec < 0 ? '-' : '+';
    const timezoneAbs = Math.abs(timezoneSec);
    const timezoneH = String(Math.floor(timezoneAbs / 3600))
      .padStart(2, '0');
    const timezoneM = String(Math.floor(timezoneAbs % 3600 / 60))
      .padStart(2, '0');
    const timezoneS = String(timezoneAbs % 60)
      .padStart(2, '0');

    /*
     * ナノ秒の数値文字列を生成する
     */
    const ns = (
      String(date.getMilliseconds()).padStart(3, '0') +
      '0'.repeat(6)
    );

    /*
     * 置換元と置換先の組み合わせを定義する
     */
    const replaceDict = {
      '%%': '%',
      '%Y': String(date.getFullYear()),
      '%-m': String(date.getMonth() + 1),
      '%m': String(date.getMonth() + 1).padStart(2, '0'),
      '%-d': String(date.getDate()),
      '%d': String(date.getDate()).padStart(2, '0'),
      '%-H': String(date.getHours()),
      '%H': String(date.getHours()).padStart(2, '0'),
      '%-M': String(date.getMinutes()),
      '%M': String(date.getMinutes()).padStart(2, '0'),
      '%-S': String(date.getSeconds()),
      '%S': String(date.getSeconds()).padStart(2, '0'),
      '%s': String(date.getTime()),
      '%N': ns,
      '%1N': ns.substr(0, 1),
      '%2N': ns.substr(0, 2),
      '%3N': ns.substr(0, 3),
      '%4N': ns.substr(0, 4),
      '%5N': ns.substr(0, 5),
      '%6N': ns.substr(0, 6),
      '%7N': ns.substr(0, 7),
      '%8N': ns.substr(0, 8),
      '%9N': ns.substr(0, 9),
      '%z': `${timezoneSign}${timezoneH}${timezoneM}`,
      '%:z': `${timezoneSign}${timezoneH}:${timezoneM}`,
      '%::z': `${timezoneSign}${timezoneH}:${timezoneM}:${timezoneS}`,
    };

    /*
     * 置換する
     * Note: この実装では、例えば"constructor"のような値を
     *       置換しようとした時に正しく動作しない。
     *       これは、オブジェクトのプロトタイプにconstructorメソッドが存在するためで、
     *       適切な動作を求めるならhasOwnPropertyメソッドで
     *       プロパティの存在判定をする必要がある。
     *       が、今回の場合はいずれも"%〜"のような値だけを置換するため、
     *       冗長な判定は使用していない。
     */
    return format.replace(
      /%(?:y|-?[mdhms%]|[1-9]n|:{0,2}z)/ig,
      match => (replaceDict[match] || match)
    );
  };

  const fullUrl = (path, baseUrl) => {
    if (/^(?:[a-z]+:)?\/\//.test(path)) {
      return path;
    } else {
      return (
        baseUrl.replace(/\/*$/, '/') +
        path.replace(/^\/+/, '')
      );
    }
  };

  /**
   * @see https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent
   */
  const encodeRFC3986URIComponent = (str, ...values) => {
    if (Array.isArray(str) && str.every(value => typeof value === 'string')) {
      /*
       * タグ付けされたTemplate literalのタグ関数として呼び出された場合
       */
      return str
        .map((string, index) => (
          0 < index ?
          encodeRFC3986URIComponent(String(values[index - 1])) + string :
          string
        ))
        .join('');
    } else {
      /*
       * その他の場合
       */
      return (
        encodeURIComponent(str)
          .replace(
            /[!'()*]/g,
            c => `%${c.charCodeAt(0).toString(16).toUpperCase()}`
          )
      );
    }
  };

  /*
   * パス、またはURL文字列を、RFC3986にある程度適合する形式に変換する。
   *
   * この関数は、RFC3986準拠の形式にパス文字列やURL文字列をエスケープする。
   * ただし、パスやURLの構造として適切な記号や、有効なパーセントエンコーディングは変換しない。
   * このため、多段エスケープを行っても、URLの構造を破壊することは無い。
   *
   * Note: 面倒なので、いくつかの形式には対応していない。
   *       例えば、IPv6のホスト名に対応していない。
   *       また、URNのような形式も想定していない。
   *       Web上で使う一般的な形式のURLと、相対パスにのみ対応。
   */
  const escapeUrlPath = (() => {
    const userinfoEscape = userinfoStr => (
      // Note: 本来ならここで、適切なエスケープ処理を行うべきだが、
      //       仕様書には明確なルールの記載が無く、また、面倒なので書いていない。
      userinfoStr
    );
    const hostEscape = hostStr => (
      // Note: 本来ならここで、非ASCII文字が紛れ込んだ場合にPunycodeのドメインへと変換
      //       する処理が必要になる。が、面倒なので書いていない。
      hostStr
    );
    /*
     * パーセントエンコーディング以外の文字をエスケープする。
     * また、パーセントエンコーディングを大文字に統一する。
     * さらに、非予約文字がパーセントエンコーディングされていた場合は元に戻す。
     */
    const segmentEscape = segmentStr => (
      segmentStr.replace(
        /[^%]|%([0-9a-f]{2})?/ig,
        (char, isPctEncoded) => (
          isPctEncoded ?
          // パーセントエンコーディングの場合、以下の処理を行う
          (
            /^%(?:2[de]|3[0-9]|4[1-9a-f]|5[0-9af]|6[1-9a-f]|7[0-9ae])$/i.test(char) ?
            // 非予約文字の場合、元に戻す
            decodeURIComponent(char) :
            // 非予約文字ではない場合、大文字に変換する
            char.toUpperCase()
          ) :
          // パーセントエンコーディングではない文字の場合、エスケープ処理を行う
          encodeRFC3986URIComponent(char)
        )
      )
    );
    const queryDataEscape = dataStr => (
      dataStr.replace(
        /^([^=]*)(?:(=)(.*))?$/,
        (_, key, equalsChar, value) => (
          segmentEscape(key || '') +
          (equalsChar || '') +
          segmentEscape(value || '')
        )
      )
    );
    const urlRegExp = /^(?:(?:([a-z0-9+.-]+):)?(?:\/\/(?:([^@/?#]*)@)?((?:[^/?#:]|:(?![0-9]*(?:[/?#]|$)))+)(?::([0-9]*))?))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?$/i;

    return pathstr => {
      pathstr = String(pathstr);

      const match = urlRegExp.exec(pathstr);

      /*
       * URLのマッチに失敗した場合は、例外を投げる
       */
      if (!match) {
        throw new URIError(
          'escapeUrlPath(pathstr): Unknown format string: ' +
          JSON.stringify(pathstr)
        );
      }

      const [, scheme, userinfo, host, port, path, query, fragment] = match;

      const authority = (
        (userinfo ? `${userinfoEscape(userinfo)}@` : '') +
        (host ? hostEscape(host) : '') +
        (port ? `:${port}` : '')
      );
      const pathStr = path
        .split(/\/+/)
        .map(segmentEscape)
        .join('/');
      const queryStr = (query || '')
        .split('&')
        .map(queryDataEscape)
        .join('&');

      return (
        (scheme ? `${scheme.toLowerCase()}:` : '') +
        (authority ? `//${authority}` : '') +
        pathStr +
        (queryStr ? `?${queryStr}` : '') +
        ((typeof fragment === 'string') ? `#${segmentEscape(fragment)}` : '')
      );
    };
  })();
